import org.jetbrains.gradle.ext.Gradle

plugins {
    id 'java'
    id 'java-library'
    id 'maven-publish'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.1.7'
    id 'eclipse'
    id 'com.gtnewhorizons.retrofuturagradle' version '1.3.16'
    id 'com.matthewprenger.cursegradle' version '1.4.0'
}

version = project.mod_version
group = project.maven_group
archivesBaseName = project.archives_base_name

// Set the toolchain version to decouple the Java we run Gradle with from the Java used to compile and run the mod
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(8))
        // Azul covers the most platforms for Java 8 toolchains, crucially including MacOS arm64
        vendor.set(org.gradle.jvm.toolchain.JvmVendorSpec.AZUL)
    }
    // Generate sources and javadocs jars when building and publishing
    withSourcesJar()
    // withJavadocJar()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

configurations {
    embed
    implementation.extendsFrom(embed)
}

minecraft {
    mcVersion = '1.12.2'

    // MCP Mappings
    mcpMappingChannel = 'stable'
    mcpMappingVersion = '39'
    
    // Set username here, the UUID will be looked up automatically
    username = 'Developer'
    
    // Add any additional tweaker classes here
    // extraTweakClasses.add('org.spongepowered.asm.launch.MixinTweaker')
    
    // Add various JVM arguments here for runtime
    def args = ["-ea:${project.group}"]
    if (project.use_coremod.toBoolean()) {
        args << '-Dfml.coreMods.load=' + coremod_plugin_class_name
    }
    if (project.use_mixins.toBoolean()) {
        args << '-Dmixin.hotSwap=true'
        args << '-Dmixin.checks.interfaces=true'
        args << '-Dmixin.debug.export=true'
    }
    extraRunJvmArguments.addAll(args)

    // Include and use dependencies' Access Transformer files
    useDependencyAccessTransformers = true
    
    // Add any properties you want to swap out for a dynamic value at build time here
    // Any properties here will be added to a class at build time, the name can be configured below
    // Example:
    // injectedTags.put('VERSION', project.version)
    // injectedTags.put('MOD_ID', project.archives_base_name)
}

// Generate a group.archives_base_name.Tags class
tasks.injectTags.configure {
    // Change Tags class' name here:
    outputClassName.set("${project.group}.${project.archives_base_name}.Tags")
}

repositories {
    maven {
        name 'CleanroomMC Maven'
        url 'https://maven.cleanroommc.com'
    }
    maven {
        name 'SpongePowered Maven'
        url 'https://repo.spongepowered.org/maven'
    }
    maven {
        name 'CurseMaven'
        url 'https://cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    mavenLocal() // Must be last for caching to work
}

dependencies {
    if (project.use_assetmover.toBoolean()) {
        implementation 'com.cleanroommc:assetmover:2.5'
    }
    if (project.use_mixins.toBoolean()) {
        implementation 'zone.rong:mixinbooter:7.1'
    }

    // Example of deobfuscating a dependency
    // implementation rfg.deobf('curse.maven:had-enough-items-557549:4543375')

    if (project.use_mixins.toBoolean()) {
        // Change your mixin refmap name here:
        String mixin = modUtils.enableMixins('org.spongepowered:mixin:0.8.3', "mixins.${project.archives_base_name}.refmap.json")
        api (mixin) {
            transitive = false
        }
        annotationProcessor 'org.ow2.asm:asm-debug-all:5.2'
        annotationProcessor 'com.google.guava:guava:24.1.1-jre'
        annotationProcessor 'com.google.code.gson:gson:2.8.6'
        annotationProcessor (mixin) {
            transitive = false
        }
    }

}

// Adds Access Transformer files to tasks
if (project.use_access_transformer.toBoolean()) {
    for (File at : sourceSets.getByName("main").resources.files) {
        if (at.name.toLowerCase().endsWith("_at.cfg")) {
            tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from(at)
            tasks.srgifyBinpatchedJar.accessTransformerFiles.from(at)
        }
    }
}

processResources {
    // This will ensure that this task is redone when the versions change
    inputs.property 'version', project.version
    inputs.property 'mcversion', project.minecraft.version
    
    // Replace various properties in mcmod.info and pack.mcmeta if applicable
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        // Replace version and mcversion
        fcd.expand (
                'version': project.version,
                'mcversion': project.minecraft.version
        )
    }
    
    if (project.use_access_transformer.toBoolean()) {
        rename '(.+_at.cfg)', 'META-INF/$1' // Make sure Access Transformer files are in META-INF folder
    }
}

jar {
    manifest {
        def attribute_map = [:]
        if (project.use_coremod.toBoolean()) {
            attribute_map['FMLCorePlugin'] = project.coremod_plugin_class_name
            if (project.include_mod.toBoolean()) {
                attribute_map['FMLCorePluginContainsFMLMod'] = true
                attribute_map['ForceLoadAsMod'] = project.gradle.startParameter.taskNames[0] == "build"
            }
        }
        if (project.use_access_transformer.toBoolean()) {
            attribute_map['FMLAT'] = project.archives_base_name + '_at.cfg'
        }
        attributes(attribute_map)
    }
    // Add all embedded dependencies into the jar
    from(provider{ configurations.embed.collect {it.isDirectory() ? it : zipTree(it)} })
}

idea {
    module {
        inheritOutputDirs = true
    }
    project {
        settings {
            runConfigurations {
                "1. Run Client"(Gradle) {
                    taskNames = ["runClient"]
                }
                "2. Run Server"(Gradle) {
                    taskNames = ["runServer"]
                }
                "3. Run Obfuscated Client"(Gradle) {
                    taskNames = ["runObfClient"]
                }
                "4. Run Obfuscated Server"(Gradle) {
                    taskNames = ["runObfServer"]
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = "-encoding utf8"
                    moduleJavacAdditionalOptions = [
                            (project.name + ".main"): tasks.compileJava.options.compilerArgs.collect { '"' + it + '"' }.join(' ')
                    ]
                }
            }
        }
    }
}

tasks.named("processIdeaSettings").configure {
    dependsOn("injectTags")
}

// Deployment
def final modrinthApiKey = providers.environmentVariable('MODRINTH_API_KEY')
def final cfApiKey = providers.environmentVariable('CURSEFORGE_API_KEY')
final boolean isCIEnv = providers.environmentVariable('CI').getOrElse('false').toBoolean()

if (isCIEnv || deploymentDebug.toBoolean()) {
    artifacts {
        if (!noPublishedSources.toBoolean()) {
            archives sourcesJar
        }
        if (apiPackage) {
            archives apiJar
        }
    }
}

// Changelog generation
tasks.register('generateChangelog') {
    group = 'GT Buildscript'
    description = 'Generate a default changelog of all commits since the last tagged git commit'
    onlyIf {
        generateDefaultChangelog.toBoolean()
    }
    doLast {
        def lastTag = getLastTag()

        def changelog = runShell(([
                "git",
                "log",
                "--date=format:%d %b %Y",
                "--pretty=%s - **%an** (%ad)",
                "${lastTag}..HEAD"
        ] + (sourceSets.main.java.srcDirs + sourceSets.main.resources.srcDirs)
                .collect { ['--', it] }).flatten())

        if (changelog) {
            changelog = "Changes since ${lastTag}:\n${{("\n" + changelog).replaceAll("\n", "\n* ")}}"
        }
        def f = getFile('build/changelog.md')
        changelog = changelog ?: 'There have been no changes.'
        f.write(changelog, 'UTF-8')

        // Set changelog for Modrinth
        if (modrinthApiKey.isPresent() || deploymentDebug.toBoolean()) {
            modrinth.changelog.set(changelog)
        }
    }
}

if (cfApiKey.isPresent() || deploymentDebug.toBoolean()) {
    apply plugin: 'net.darkhax.curseforgegradle'
    //noinspection UnnecessaryQualifiedReference
    tasks.register('curseforge', net.darkhax.curseforgegradle.TaskPublishCurseForge) {
        disableVersionDetection()
        debugMode = deploymentDebug.toBoolean()
        apiToken = cfApiKey.getOrElse('debug_token')

        doFirst {
            def mainFile = upload(curseForgeProjectId, reobfJar)
            def changelogFile = getChangelog()
            def changelogRaw = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""

            mainFile.displayName = "${modName}: ${modVersion}"
            mainFile.releaseType = getReleaseType()
            mainFile.changelog = changelogRaw
            mainFile.changelogType = 'markdown'
            mainFile.addModLoader 'Forge'
            mainFile.addJavaVersion "Java 8"
            mainFile.addGameVersion minecraftVersion

            if (curseForgeRelations.size() != 0) {
                String[] deps = curseForgeRelations.split(';')
                deps.each { dep ->
                    if (dep.size() == 0) {
                        return
                    }
                    String[] parts = dep.split(':')
                    String type = parts[0], slug = parts[1]
                    if (!(type in ['requiredDependency', 'embeddedLibrary', 'optionalDependency', 'tool', 'incompatible'])) {
                        throw new Exception('Invalid Curseforge dependency type: ' + type)
                    }
                    mainFile.addRelation(slug, type)
                }
            }

            for (artifact in getSecondaryArtifacts()) {
                def additionalFile = mainFile.withAdditionalFile(artifact)
                additionalFile.changelog = changelogRaw
            }
        }
    }
    tasks.curseforge.dependsOn(build)
    tasks.curseforge.dependsOn('generateChangelog')
}

if (modrinthApiKey.isPresent() || deploymentDebug.toBoolean()) {
    apply plugin: 'com.modrinth.minotaur'
    def final changelogFile = getChangelog()

    modrinth {
        token = modrinthApiKey.getOrElse('debug_token')
        projectId = modrinthProjectId
        changelog = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""
        versionType = getReleaseType()
        versionNumber = modVersion
        gameVersions = [minecraftVersion]
        loaders = ["forge"]
        debugMode = deploymentDebug.toBoolean()
        uploadFile = reobfJar
        additionalFiles = getSecondaryArtifacts()
    }
    if (modrinthRelations.size() != 0) {
        String[] deps = modrinthRelations.split(';')
        deps.each { dep ->
            if (dep.size() == 0) {
                return
            }
            String[] parts = dep.split(':')
            String[] qual = parts[0].split('-')
            addModrinthDep(qual[0], qual[1], parts[1])
        }
    }
    tasks.modrinth.dependsOn(build)
    tasks.modrinth.dependsOn('generateChangelog')
}

def addModrinthDep(String scope, String type, String name) {
    com.modrinth.minotaur.dependencies.Dependency dep
    if (!(scope in ['required', 'optional', 'incompatible', 'embedded'])) {
        throw new Exception('Invalid modrinth dependency scope: ' + scope)
    }
    switch (type) {
        case 'project':
            dep = new ModDependency(name, scope)
            break
        case 'version':
            dep = new VersionDependency(name, scope)
            break
        default:
            throw new Exception('Invalid modrinth dependency type: ' + type)
    }
    project.modrinth.dependencies.add(dep)
}

if (customMavenPublishUrl) {
    String publishedVersion = modVersion

    publishing {
        publications {
            create('maven', MavenPublication) {
                //noinspection GroovyAssignabilityCheck
                from components.java

                if (apiPackage) {
                    artifact apiJar
                }

                // providers is not available here, use System for getting env vars
                groupId = System.getenv('ARTIFACT_GROUP_ID') ?: project.group
                artifactId = System.getenv('ARTIFACT_ID') ?: project.name
                version = System.getenv('RELEASE_VERSION') ?: publishedVersion
            }
        }

        repositories {
            maven {
                url = customMavenPublishUrl
                allowInsecureProtocol = !customMavenPublishUrl.startsWith('https')
                credentials {
                    username = providers.environmentVariable('MAVEN_USER').getOrElse('NONE')
                    password = providers.environmentVariable('MAVEN_PASSWORD').getOrElse('NONE')
                }
            }
        }
    }
}

def getSecondaryArtifacts() {
    def secondaryArtifacts = [usesShadowedDependencies.toBoolean() ? tasks.shadowJar : tasks.jar]
    if (!noPublishedSources.toBoolean()) secondaryArtifacts += [sourcesJar]
    if (apiPackage) secondaryArtifacts += [apiJar]
    return secondaryArtifacts
}

def getReleaseType() {
    String type = project.releaseType
    if (!(type in ['release', 'beta', 'alpha'])) {
        throw new Exception("Release type invalid! Found \"" + type + "\", allowed: \"release\", \"beta\", \"alpha\"")
    }
    return type
}

/*
 * If CHANGELOG_LOCATION env var is set, that takes highest precedence.
 * Next, if 'generateDefaultChangelog' option is enabled, use that.
 * Otherwise, try to use a CHANGELOG.md file at root directory.
 */
def getChangelog() {
    def final changelogEnv = providers.environmentVariable('CHANGELOG_LOCATION')
    if (changelogEnv.isPresent()) {
        return new File(changelogEnv.get())
    }
    if (generateDefaultChangelog.toBoolean()) {
        return getFile('build/changelog.md')
    }
    return getFile('CHANGELOG.md')
}


// Buildscript updating

def buildscriptGradleVersion = '8.2.1'

tasks.named('wrapper', Wrapper).configure {
    gradleVersion = buildscriptGradleVersion
}

tasks.register('updateBuildScript') {
    group = 'GT Buildscript'
    description = 'Updates the build script to the latest version'

    if (gradle.gradleVersion != buildscriptGradleVersion && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_GRADLE_UPDATE')) {
        dependsOn('wrapper')
    }

    doLast {
        if (performBuildScriptUpdate()) return
        print('Build script already up to date!')
    }
}

if (!project.getGradle().startParameter.isOffline() && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_UPDATE_CHECK') && isNewBuildScriptVersionAvailable()) {
    if (autoUpdateBuildScript.toBoolean()) {
        performBuildScriptUpdate()
    } else {
        out.style(Style.SuccessHeader).println("Build script update available! Run 'gradle updateBuildScript'")
        if (gradle.gradleVersion != buildscriptGradleVersion) {
            out.style(Style.SuccessHeader).println("updateBuildScript can update gradle from ${gradle.gradleVersion} to ${buildscriptGradleVersion}\n")
        }
    }
}

static URL availableBuildScriptUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/build.gradle")
}

static URL availableSettingsGradleUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/settings.gradle")
}

boolean performBuildScriptUpdate() {
    if (isNewBuildScriptVersionAvailable()) {
        def buildscriptFile = getFile("build.gradle")
        def settingsFile = getFile("settings.gradle")
        availableBuildScriptUrl().withInputStream { i -> buildscriptFile.withOutputStream { it << i } }
        availableSettingsGradleUrl().withInputStream { i -> settingsFile.withOutputStream { it << i } }
        def out = services.get(StyledTextOutputFactory).create('buildscript-update-output')
        out.style(Style.Success).print("Build script updated. Please REIMPORT the project or RESTART your IDE!")
        return true
    }
    return false
}

boolean isNewBuildScriptVersionAvailable() {
    Map parameters = ["connectTimeout": 10000, "readTimeout": 10000]

    String currentBuildScript = getFile("build.gradle").getText()
    String currentBuildScriptHash = getVersionHash(currentBuildScript)
    String availableBuildScript = availableBuildScriptUrl().newInputStream(parameters).getText()
    String availableBuildScriptHash = getVersionHash(availableBuildScript)

    boolean isUpToDate = currentBuildScriptHash.empty || availableBuildScriptHash.empty || currentBuildScriptHash == availableBuildScriptHash
    return !isUpToDate
}

static String getVersionHash(String buildScriptContent) {
    String versionLine = buildScriptContent.find("^//version: [a-z0-9]*")
    if (versionLine != null) {
        return versionLine.split(": ").last()
    }
    return ""
}


// Faq

tasks.register('faq') {
    group = 'GT Buildscript'
    description = 'Prints frequently asked questions about building a project'
    doLast {
        print("\nTo update this buildscript to the latest version, run 'gradlew updateBuildScript' or run the generated run configuration if you are using IDEA.\n" +
                "To set up the project, run the 'setupDecompWorkspace' task, which you can run as './gradlew setupDecompWorkspace' in a terminal, or find in the 'modded minecraft' gradle category.\n\n" +
                "To add new dependencies to your project, place them in 'dependencies.gradle', NOT in 'build.gradle' as they would be replaced when the script updates.\n" +
                "To add new repositories to your project, place them in 'repositories.gradle'.\n" +
                "If you need additional gradle code to run, you can place it in a file named 'addon.gradle' (or either of the above, up to you for organization).\n\n" +
                "If your build fails to recognize the syntax of newer Java versions, enable Jabel in your 'gradle.properties' under the option name 'enableModernJavaSyntax'.\n" +
                "To see information on how to configure your IDE properly for Java 17, see https://github.com/GregTechCEu/Buildscripts/blob/master/docs/jabel.md\n\n" +
                "Report any issues or feature requests you have for this build script to https://github.com/GregTechCEu/Buildscripts/issues\n")
    }
}


// Helpers

def getFile(String relativePath) {
    return new File(projectDir, relativePath)
}

def checkPropertyExists(String propertyName) {
    if (!project.hasProperty(propertyName)) {
        throw new GradleException("This project requires a property \"" + propertyName + "\"! Please add it your \"gradle.properties\". You can find all properties and their description here: https://github.com/GregTechCEu/Buildscripts/blob/main/gradle.properties")
    }
}

def propertyDefaultIfUnset(String propertyName, defaultValue) {
    if (!project.hasProperty(propertyName) || project.property(propertyName) == "") {
        project.ext.setProperty(propertyName, defaultValue)
    }
}

def propertyDefaultIfUnsetWithEnvVar(String propertyName, defaultValue, String envVarName) {
    def envVar = providers.environmentVariable(envVarName)
    if (envVar.isPresent()) {
        project.ext.setProperty(propertyName, envVar.get())
    } else {
        propertyDefaultIfUnset(propertyName, defaultValue)
    }
}

static runShell(command) {
    def process = command.execute()
    def outputStream = new StringBuffer()
    def errorStream = new StringBuffer()
    process.waitForProcessOutput(outputStream, errorStream)

    errorStream.toString().with {
        if (it) {
            throw new GradleException("Error executing ${command}:\n> ${it}")
        }
    }
    return outputStream.toString().trim()
}

def getLastTag() {
    def githubTag = providers.environmentVariable('GITHUB_TAG')
    return runShell('git describe --abbrev=0 --tags ' +
            (githubTag.isPresent() ? runShell('git rev-list --tags --skip=1 --max-count=1') : ''))
}
